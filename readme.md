## Koa-node-数独游戏

* #### 文档结构   

1. app 服务端代码
2. src   前端代码
3. task   gulp任务模块

##

这是一个通过Koa框架搭建的数独游戏，力求使用最少的插件来运行此应用。主要通过一个数独游戏来实际运用ES6，该项目将数独游戏作为前端模块开发（非后端模块），该项目遵循模块开发理念，尽量将模块功能单一化可扩展化，另外在代码中对于比较难以理解的部分做了较为详细的注释，以便更好了解数独游戏的核心和一些巧妙算法的理解。

* #### 开发环境  

1. node >= v.6.x
2. gulp+webpack 自动化任务部署
3. ES6
4. 服务端默认模板为nunjucks模板，模板位于views文件夹内，数据植入方式请参考app/lib/route下的index.js文件

本应用将前后端代码进行了剥离，只需要专注于前端代码的编写。
`本应用采用Bulma CSS框架开发`
[Bulma](https://bulma.io/)


* #### 特色之处

首先该项目中的数独游戏，非本人原创，[此处为原创](https://www.imooc.com/learn/899)，我在原创基础上，优化了UI模块的结构、M/V之间数据交换的优化、在数据检查上做了优化（仅对隐藏数据进行检查）、采用了promise对象来实现M/V之间的数据交换、添加了symbol类型作为类的私有属性。

这里也非常感谢‘边城’无私（免费）的提供了数独游戏的核心算法，让我获益匪浅。

1. 这是一个功能比较完整的HTML数独游戏
2. 各个功能模块可扩展性强，MVC思维方式来编写对象模块
3. 对ES6技术运用较多，其中包括模板字符串、解构赋值、symbol实现类的私有属性、数组填充、promise等
4. 整个HTML的布局都采用bulmaCSS框架的flex布局。同时在标记棋盘和数字填充上面，都是使用了css原生动画实现，在test的文件夹中有我对这些css动画的编写和测试。
5. 非常适合用于ES6技术实践

* #### 测试模块

1. 编辑src/test.js 
2. gulp test
3. 打开test/index.html 查看运行结果


* #### 启动应用 

1. npm install
2. npm start

自动刷新插件默认启动4000端口，服务启动3000端口，注意自动刷新插件默认设置的是打开chrome浏览器，可以在tasks目录下的server.js中的第30行来修改此设置

更改服务端口
```
1. app/app.js
2. tasks/server.js  --> 更改browserSync.init中proxy的值   
```

更改自动刷新端口
```
1. tasks/server.js  --> 更改browserSync.init中port的值   
```


关于项目中的box_position.png，为了让大家能更好明白数独游戏中坐标关系，
该图是@边城__在数独游戏教程中的图片。

[数独游戏演示地址](https://jacecao.github.io/node-shudu/)

##

### 关于数独游戏需要说明的

* #### flex布局与绝对定位

在使用flex布局时，对需要绝对定位的元素不可以作为flex布局中的子盒子

即当父容器为flex布局时，其子元素如果为绝对定位元素，那么该子元素绝对定位是无法准确定位的
在父容器出现尺寸变化时，是无法实现绝对定位。

必须将绝对定位元素包裹于父容器中的子容器中
这里的数独游戏中数字转盘就是使用此方法实现绝对定位的


* #### chrome 和 Safari css表现存在的差异


两者在width和height为100%时存在很大的差异，当元素如果在css文件中对父级元素作了初始宽高的设置（注意这里的初始是指浏览器渲染后的初始，非CSS中设置的），那么在两者上面的表现都没有任何差异。**但是如果元素通过JS来控制了宽高**那么问题就出现了，chrome依然会自动计算当前的宽高，而safari不会依然引用父级元素CSS中原始值。

而当width/height设置为inherit时，两者的表现都是一样的，不会去自动计算宽高，都统一为父元素默认值。

遇到的一点点麻烦，由于所有的表格都需要重新计算高度，而后面错误标记动画元素又是当前表格的伪元素（且又是绝对定位），由于表格高度是动态的，那么我们伪元素定位就存在麻烦，一开始我们给伪元素设定的是宽/高100%，但在Safari上面就出现了[这样的意外](https://jacecao.github.io/node-shudu/css-bug/)-(使用Safari浏览器打开，点击第一个方格)。最后解决方案是结合上面两个特点，我对不需要做数据变动的宽度设置为100%，对需要变动的高度设置为inherit。嗯，如我所愿两者都能很好的兼容。

* ### 如何防止数据污染

在render.js模块中，我们需要通过模板数据来渲染棋盘
注意这个地方有一个坑，那就是我在轮盘输入数据时，会更改这个模板数据，并同时对填写数据做一个是否重复填写的检查，
这个时候就需要注意，为了防止这个数据污染到shuduku.js模块中的模板数据，我们就需要单独复制一份模板数据用于视图渲染，如何理解引用类型的数据(这需要对引用类型的数据非常熟悉)才会避免这个坑。

这个坑还会出现在另外两个地方

1. 最开始构建的二维数组工具matrixTool.js
2. shuduku.js生成迷盘数组的方法中

**针对该项目的中心要点就是对参数为引用类型的数据采用复制再存储**

* ### 避免多次生成实例

在这个数独游戏中，我们只生成一次实例，后面的所有操作都是对实例方法的使用，为什么呢？这是因为一个游戏或者一个拥有较多功能的应用都会有很多属性连续且贯穿整个模块的前后文（至少在用户未采用重启前，我们需要保留这些属性的动态值)。

这里面，需要注意的是map这个数据类型，map数据是非常好的实时数据库，一旦写入数据，如果我们不手动清空，这些数据是一直会存在的（除非重启应用），所以我们需要在代码中手动清空map数据。

* #### 已知BUG

下方按钮的检查信息动画未能正常显示

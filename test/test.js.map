{"version":3,"names":[],"mappings":"","sources":["test.js"],"sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _matrix = __webpack_require__(2);\n\nvar _matrix2 = _interopRequireDefault(_matrix);\n\nvar _tool = __webpack_require__(3);\n\nvar _tool2 = _interopRequireDefault(_tool);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// export default {name: 'test'}\nvar items = _matrix2.default.makeMatrix();\nvar _arrs = items.map(function (item) {\n  return item.map(function (v, i) {\n    return i;\n  });\n});\nvar arrs = _arrs.map(function (arr) {\n  return _tool2.default.shuffle(arr);\n});\nconsole.log(arrs);\n\nvar cell = _tool2.default.convertPosition(5, 6);\nconsole.log(cell);\nvar box_arr = _matrix2.default.box_matrix(arrs, cell.rowIndex, cell.colIndex);\nconsole.log(box_arr);\nconsole.log(arrs[cell.rowIndex][cell.colIndex]);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n// 9 * 9 二维基础数组生成 和 费雪耶兹排序随机排序\nexports.default = {\n\n\t//生成一个一维数组\n\tmakeRow: function makeRow() {\n\t\tvar v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n\t\tvar array = new Array(9);\n\t\tarray.fill(v);\n\t\treturn array;\n\t},\n\n\n\t// 生成一个二维数组\n\tmakeMatrix: function makeMatrix() {\n\t\tvar _this = this;\n\n\t\tvar v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n\t\t// 注意这里我们为什么不采用上面的方法来生产二维数组呢？\n\t\t/*\n  const array = new Array(9);\n  array.fill(makeRow(v));\n  return array;\n   */\n\t\t// 如果我们按照上面方法生产一个二维数组，那么二维数组内的\n\t\t// 所有一维数组都将指向makeRow(v)运行一次后得到的数据\n\t\t// 这样的后果就是一旦其中一个一维数组发生变化，将导致所有的一维\n\t\t// 数组发生变化，这不是我们所希望的\n\n\t\t// 下面这样的做法，是每个一维数组都会通过运行makeRow()\n\t\t// 来得到一个新的数组（这里主要就是需要理解引用类型数据的运作机制）\n\t\treturn Array.from({ length: 9 }, function () {\n\t\t\treturn _this.makeRow(v);\n\t\t});\n\t},\n\n\n\t// 获取九宫格数组\n\t// matrix: 二维数组\n\t// row_index: 第一维起始索引\n\t// col_index: 第二维起始索引\n\t// 取值方式如下所示：\n\t// [（matri数组中的一部分）\n\t// \t[a,b,c],  [0,1,2\n\t// \t[1,2,3],  3,4,5\n\t// \t[o,p,q]   6,7,8]\n\t// ]\n\t// 通过该方法，以a元素的索引为起点，将a,b,c,1,2,3,o,p,q取出\n\t// 注意这里返回的是一个长度为9的数组\n\tbox_matrix: function box_matrix(matrix) {\n\t\tvar row_index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\tvar col_index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n\t\tvar box_arr = [];\n\t\t// 保存每列的起始位置\n\t\tvar _start_index = col_index;\n\t\t// 保存将要取值目标的位置\n\t\tvar _target_index = col_index;\n\t\tfor (var i = 0; i < 9; i++) {\n\t\t\tif (i != 0 && i % 3 == 0) {\n\t\t\t\t// 这里是保证每一行只取三个值\n\t\t\t\t// 取满三个值后转入下一列\n\t\t\t\trow_index += 1;\n\t\t\t\t_target_index = _start_index;\n\t\t\t}\n\t\t\tbox_arr.push(matrix[row_index][_target_index]);\n\t\t\t_target_index += 1;\n\t\t}\n\t\t// 返回我们最终的取值\n\t\tif (box_arr.length != 9) {\n\t\t\tconsole.info('box_matrix was failed');\n\t\t} else {\n\t\t\treturn box_arr;\n\t\t}\n\t}\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n// 辅助数据检查工具\nexports.default = {\n\t// 九宫格坐标换算\n\t// 这里的box_x / y是什么意思呢？\n\t// 就是指在九宫格中每个格的坐标位置 请参考box_position.png\n\t/*  \n ** 九宫格中每个宫的坐标是这样的\n **  (0, 0)   (1, 0)   (2, 0)\n **  \n **  (0, 1)   (1, 1)   (2, 1)\n **\n **  (0, 2)   (1, 2)   (2, 2)\n  */\n\t// 下面box_x/y就代表每个宫的（x,y）坐标\n\t// 而这个宫坐标就是通过 9 * 9 这样的坐标来确定的\n\t// 如下面的排列，这就反应了9 * 9二维数组与九宫格的关系\n\t/*  0  1  2 | 3  4 5| 6 7 8\n **  1 (0,0) | (1,0) | (2,0)\n *   2       |       |\n *   ........................\n *   3 (0,1) | (1,1) | (1,2)\n *   4       |       |\n *   5       |       |\n *   ........................\n *   6 (0,2) | (1,2) | (2,2)\n *   7       |       |\n *   8       |       | \n  */\n\t// row_index col_index 是二维数组中的坐标（也就是索引值）\n\t// row_index 第一维数组的索引\n\t// col_index 第二维数组中的所有\n\tconvertPosition: function convertPosition(row_index, col_index) {\n\t\t// box_position 用于储存九宫格中宫的坐标\n\t\tvar box_x = Math.floor(col_index / 3);\n\t\tvar box_y = Math.floor(row_index / 3);\n\t\t// 根据上面的宫坐标，接下来，我们需要确定宫中格子的坐标\n\t\t// 首要目标是确定一个格子的坐标\n\t\t// 需要注意这里的格子坐标，实际是指在二维数组中的索引\n\t\t// 如下面示意，这里我们展示其中一个宫中的数据\n\t\t/*\n     （box_x, box_y） = (1, 2);\n        宫坐标为（1，2）中的数据\n  \t\t-------------\n  \t\t| 0 | 1 | 2 |\n  \t\t-------------\n  \t\t| 3 | 4 | 5 |\n  \t\t-------------\n  \t\t| 6 | 7 | 8 |\n  \t\t-------------\n   */\n\t\t// 我们需要确定0这个格在二维数组中的索引\n\t\t// 我们通过0这个格子的索引，就能确定这9个格子在二维数组中的索引\n\t\t// 通过该索引我们就能获取这个9个格子所拥有的值\n\t\t// 这样就方便检查工具，检查在一个宫中是否有重复的值\n\t\tvar cell_x = box_x * 3;\n\t\tvar cell_y = box_y * 3;\n\t\t// 注意我们需要将这里的x,y对应二维数组转换为索引\n\t\t// 第一维索引对应的是y坐标,第二维对应的是x坐标\n\t\t// cell_first 的row_index = cell_y, col_index = cell_x\n\t\t// 根据这个方法，我们就可以确定宫坐标为（1，2）中第一个格子\n\t\t// 在二维数组中的索引就是（3，6）\n\t\t// 第一维数组中的索引为3，第二维数组中的索引为6\n\t\t// ***【这里如果理解困难请参考box_positions.png】***\n\t\treturn { rowIndex: cell_y, colIndex: cell_x };\n\t},\n\n\t/*\n ** Fisher-Yates 费雪耶兹随机置乱算法\n **\n  */\n\tshuffle: function shuffle(array) {\n\t\t// 需要运算的次数，应该是array.length - 1\n\t\t// 因为最后一次不需要作任何运算，所以就不需要执行\n\t\t// 这里需要理解这种算法的特点才行\n\t\tvar endIndex = array.length - 2;\n\t\tfor (var i = 0; i <= endIndex; i++) {\n\t\t\t/*\n    取得一个随机数\n    注意随机的数据必须是当前遍历到的数据的后面的数据\n    什么意思呢？\n    a = [1,2,3,4,5]\n    如果当前已经遍历到2这个数值\n    那么随机取值就必须是在2后面的数据中随机抽取\n    也就是只能在3，4，5中取得\n    下面这个_r就是这个用意\n   */\n\t\t\t// Math.random() * array.length\n\t\t\t// 这个取值范围就是 0 和 array.length 之间 但不包含array.length\n\t\t\tvar _r = i + Math.floor(Math.random() * (array.length - i));\n\t\t\t// 将随机取得的值替换当前遍历的值\n\t\t\t// 这里我们通过解构来赋值\n\t\t\tvar _ref = [array[_r], array[i]];\n\t\t\tarray[i] = _ref[0];\n\t\t\tarray[_r] = _ref[1];\n\t\t}\n\t\treturn array;\n\t}\n};\n\n/***/ })\n/******/ ]);"],"file":"test.js"}
{"version":3,"names":[],"mappings":"","sources":["test.js"],"sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n// 9 * 9 二维基础数组生成 和 费雪耶兹排序随机排序\n// 该模块返回的都是数组\nexports.default = {\n\n\t//生成一个一维数组\n\tmakeRow: function makeRow() {\n\t\tvar v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n\t\tvar array = new Array(9);\n\t\tarray.fill(v);\n\t\treturn array;\n\t},\n\n\n\t// 生成一个二维数组\n\tmakeMatrix: function makeMatrix() {\n\t\tvar _this = this;\n\n\t\tvar v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n\t\t// 注意这里我们为什么不采用上面的方法来生产二维数组呢？\n\t\t/*\n  const array = new Array(9);\n  array.fill(makeRow(v));\n  return array;\n   */\n\t\t// 如果我们按照上面方法生产一个二维数组，那么二维数组内的\n\t\t// 所有一维数组都将指向makeRow(v)运行一次后得到的数据\n\t\t// 这样的后果就是一旦其中一个一维数组发生变化，将导致所有的一维\n\t\t// 数组发生变化，这不是我们所希望的\n\n\t\t// 下面这样的做法，是每个一维数组都会通过运行makeRow()\n\t\t// 来得到一个新的数组（这里主要就是需要理解引用类型数据的运作机制）\n\t\treturn Array.from({ length: 9 }, function () {\n\t\t\treturn _this.makeRow(v);\n\t\t});\n\t},\n\n\n\t// 获取九宫格数组\n\t// matrix: 二维数组\n\t// row_index: 宫内第一个元素的第一维起始索引\n\t// col_index: 宫内第一个元素的第二维起始索引\n\t// 取值方式如下所示：\n\t// [（matri数组中的一部分）\n\t// \t[a,b,c],  [0,1,2\n\t// \t[1,2,3],  3,4,5\n\t// \t[o,p,q]   6,7,8]\n\t// ]\n\t// 通过该方法，以a元素的索引为起点，将a,b,c,1,2,3,o,p,q取出\n\t// 注意这里返回的是一个长度为9的数组\n\tboxMatrix: function boxMatrix(matrix) {\n\t\tvar row_index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\tvar col_index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n\t\t// 保存九宫格数组\n\t\tvar box_arr = [];\n\t\t// 保存九宫格中每个值对应的索引\n\t\tvar box_index = [];\n\t\t// 保存每列的起始位置\n\t\tvar _start_index = col_index;\n\t\t// 保存将要取值目标的位置\n\t\tvar _target_index = col_index;\n\t\tfor (var i = 0; i < 9; i++) {\n\t\t\t// 注意这里需要排除 i = 0（也就是在初始行中取完3个值以后才能进入下一列）\n\t\t\t// 如果不排除 i=0 ，那么一开始就会跳入到下一列进行取值，违背我们的初衷\n\t\t\tif (i != 0 && i % 3 == 0) {\n\t\t\t\t// 这里是保证每一行只取三个值\n\t\t\t\t// 取满三个值后转入下一列\n\t\t\t\trow_index += 1;\n\t\t\t\t_target_index = _start_index;\n\t\t\t}\n\t\t\tbox_arr.push(matrix[row_index][_target_index]);\n\t\t\tbox_index.push({ rowIndex: row_index, colIndex: _target_index });\n\t\t\t_target_index += 1;\n\t\t}\n\t\t// 返回我们最终的取值\n\t\tif (box_arr.length != 9) {\n\t\t\tconsole.info('box_matrix was failed');\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn { boxValue: box_arr, boxValueIndex: box_index };\n\t\t}\n\t}\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n// 辅助数据检查工具\nexports.default = {\n\t// 九宫格坐标换算\n\t// 这里的box_x / y是什么意思呢？\n\t// 就是指在九宫格中每个格的坐标位置 请参考box_position.png\n\t/*  \n ** 九宫格中每个宫的坐标是这样的\n **  (0, 0)   (1, 0)   (2, 0)\n **  \n **  (0, 1)   (1, 1)   (2, 1)\n **\n **  (0, 2)   (1, 2)   (2, 2)\n  */\n\t// 下面box_x/y就代表每个宫的（x,y）坐标\n\t// 而这个宫坐标就是通过 9 * 9 这样的坐标来确定的\n\t// 如下面的排列，这就反应了9 * 9二维数组与九宫格的关系\n\t/*  0  1  2 | 3  4 5| 6 7 8\n **  1 (0,0) | (1,0) | (2,0)\n *   2       |       |\n *   ........................\n *   3 (0,1) | (1,1) | (1,2)\n *   4       |       |\n *   5       |       |\n *   ........................\n *   6 (0,2) | (1,2) | (2,2)\n *   7       |       |\n *   8       |       | \n  */\n\t// row_index col_index 是二维数组中的坐标（也就是索引值）\n\t// row_index 第一维数组的索引\n\t// col_index 第二维数组中的所有\n\tconvertPosition: function convertPosition(row_index, col_index) {\n\t\t// box_x/y 用于储存九宫格中宫的坐标\n\t\tvar box_x = Math.floor(col_index / 3);\n\t\tvar box_y = Math.floor(row_index / 3);\n\t\t// 根据上面的宫坐标，接下来，我们需要确定宫中格子的坐标\n\t\t// 首要目标是确定一个格子的坐标\n\t\t// 需要注意这里的格子坐标，实际是指在二维数组中的索引\n\t\t// 如下面示意，这里我们展示其中一个宫中的数据\n\t\t/*\n     （box_x, box_y） = (1, 2);\n        宫坐标为（1，2）中的数据\n  \t\t-------------\n  \t\t| 0 | 1 | 2 |\n  \t\t-------------\n  \t\t| 3 | 4 | 5 |\n  \t\t-------------\n  \t\t| 6 | 7 | 8 |\n  \t\t-------------\n   */\n\t\t// 我们需要确定0这个格在二维数组中的索引\n\t\t// 我们通过0这个格子的索引，就能确定这9个格子在二维数组中的索引\n\t\t// 通过该索引我们就能获取这个9个格子所拥有的值\n\t\t// 这样就方便检查工具，检查在一个宫中是否有重复的值\n\t\tvar cell_x = box_x * 3;\n\t\tvar cell_y = box_y * 3;\n\t\t// 注意我们需要将这里的x,y对应二维数组转换为索引\n\t\t// 第一维索引对应的是y坐标,第二维对应的是x坐标\n\t\t// cell_first 的row_index = cell_y, col_index = cell_x\n\t\t// 根据这个方法，我们就可以确定宫坐标为（1，2）中第一个格子\n\t\t// 在二维数组中的索引就是（3，6）\n\t\t// 第一维数组中的索引为3，第二维数组中的索引为6\n\t\t// ***【这里如果理解困难请参考box_positions.png】***\n\n\t\t// 这里返回的是一个对象\n\t\t// 该对象为 ’当前索引指向的值‘ 所在的’宫‘中第一个元素在9 * 9 二维数组中的 ’索引‘\n\t\treturn { rowIndex: cell_y, colIndex: cell_x };\n\t},\n\n\n\t// 根据宫的索引值来获取宫的首个元素的索引值\n\t// box_index 为宫的索引值\n\t/*  0  1  2 | 3  4 5| 6 7 8\n **  1 ( 0 ) | ( 1 ) | ( 2 )\n *   2       |       |\n *   ........................\n *   3 ( 3 ) | ( 4 ) | ( 5 )\n *   4       |       |\n *   5       |       |\n *   ........................\n *   6 ( 6 ) | ( 7 ) | ( 8 )\n *   7       |       |\n *   8       |       | \n  */\n\tconvertBox: function convertBox() {\n\t\tvar box_index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n\t\tvar first_cell_col = box_index % 3 * 3;\n\t\tvar first_cell_row = Math.floor(box_index / 3) * 3;\n\t\treturn {\n\t\t\trowIndex: first_cell_row,\n\t\t\tcolIndex: first_cell_col\n\t\t};\n\t},\n\n\n\t// 获取二维数组中指定列的数值\n\t// matrix 二维数组\n\t// colIndex 指定的列\n\tgetCol: function getCol(matrix, colIndex) {\n\t\t// 保存列中的数值\n\t\tvar arr = [];\n\t\tfor (var i = 0; i < 9; i++) {\n\t\t\tarr.push(matrix[i][colIndex]);\n\t\t};\n\t\treturn arr;\n\t},\n\n\t/*\n ** Fisher-Yates 费雪耶兹随机置乱算法\n **\n  */\n\tshuffle: function shuffle(array) {\n\t\t// 需要运算的次数，应该是array.length - 1\n\t\t// 因为最后一次不需要作任何运算，所以就不需要执行\n\t\t// 这里需要理解这种算法的特点才行\n\t\tvar endIndex = array.length - 2;\n\t\tfor (var i = 0; i <= endIndex; i++) {\n\t\t\t/*\n    取得一个随机数\n    注意随机的数据必须是当前遍历到的数据的后面的数据\n    什么意思呢？\n    a = [1,2,3,4,5]\n    如果当前已经遍历到2这个数值\n    那么随机取值就必须是在2后面的数据中随机抽取\n    也就是只能在3，4，5中取得\n    下面这个_r就是这个用意\n   */\n\t\t\t// Math.random() * array.length\n\t\t\t// 这个取值范围就是 0 和 array.length 之间 但不包含array.length\n\t\t\tvar _r = i + Math.floor(Math.random() * (array.length - i));\n\t\t\t// 将随机取得的值替换当前遍历的值\n\t\t\t// 这里我们通过解构来赋值\n\t\t\tvar _ref = [array[_r], array[i]];\n\t\t\tarray[i] = _ref[0];\n\t\t\tarray[_r] = _ref[1];\n\t\t}\n\t\treturn array;\n\t}\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Checker = exports.checkerTool = undefined;\n\nvar _tool = __webpack_require__(1);\n\nvar _tool2 = _interopRequireDefault(_tool);\n\nvar _matrix = __webpack_require__(0);\n\nvar _matrix2 = _interopRequireDefault(_matrix);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } // 检查对象\n\n\nvar checkerTool = {\n\n\t// 检查数值在九宫内填写合法\n\t/* matrix 九宫二维数组\n ** n 需要填入的数值\n ** row_index 行索引值\n ** col_index 列索引值\n **/\n\tcheckFillable: function checkFillable(matrix, n, row_index, col_index) {\n\t\t// 按行、按列、按宫来检查数据\n\t\t// 抽取行数据\n\t\tvar row_arr = matrix[row_index];\n\t\t// 抽取列数据\n\t\tvar col_arr = _tool2.default.getCol(matrix, col_index);\n\t\t// 抽取宫数据\n\t\tvar box_arr = [];\n\t\t// 对象结构赋值\n\t\t// tool.convertPosition 返回的是 {rowIndex: xxx, colIndex: xxxx}\n\n\t\tvar _tool$convertPosition = _tool2.default.convertPosition(row_index, col_index),\n\t\t    rowIndex = _tool$convertPosition.rowIndex,\n\t\t    colIndex = _tool$convertPosition.colIndex;\n\t\t// 这里也是对象结构赋值matrixTool.boxMatrix 返回 {boxValue:xxx, boxValueIndex:xx}\n\n\n\t\tvar _matrixTool$boxMatrix = _matrix2.default.boxMatrix(matrix, rowIndex, colIndex),\n\t\t    boxValue = _matrixTool$boxMatrix.boxValue;\n\n\t\tif (boxValue) {\n\t\t\tbox_arr = boxValue;\n\t\t} else {\n\t\t\tconsole.log('\\u83B7\\u53D6\\u2018\\u5BAB\\u5185\\u2019\\u6570\\u636E\\u5931\\u8D25\\uFF0Cbox_obj: ' + box_obj);\n\t\t}\n\n\t\tfor (var i = 0; i < 9; i++) {\n\t\t\tif (row_arr[i] == n || col_arr[i] == n || box_arr[i] == n) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\n\t/*\n ** 数独-检查-标记\n ** array 一维数组\n ** 这里我们使用的检查核心依然是一张表\n ** 目前我们在制作数独游戏中已经有了2张数据表\n ** 这两张数据表产生于make类\n ** 1张是生成的数独二维数据表， 这张表将用于记录当前执行代码过程中生成的正确数独排序\n ** 1张是生成上面的数独排序表时，我们所采用的随机序列表，通过该表来随机生成数独排序\n ** 那么当前我们检查数组内的值是否符合数独游戏，那么需要生成一张新的表，用于记录用户\n ** 填写的数据的正确和错误，这三张表都是一一对应的关系\n ** checkArray就是用于组成这张表的\n */\n\tcheckArray: function checkArray(array) {\n\t\tvar len = array.length;\n\t\t// 创建检查标记数组\n\t\tvar marks = new Array(9);\n\t\t// 标记数组初始值都为true\n\t\tmarks.fill(true);\n\n\t\tfor (var i = 0; i < len - 1; i++) {\n\t\t\tvar v = array[i];\n\t\t\t// 如果当前位置的标记为false\n\t\t\t// 那么跳过本次检查\n\t\t\tif (!marks[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 如果当前值为0 ， 那么为false\n\t\t\t// 注意，这里我们需要注意，数独中没填写的空位 0 \n\t\t\tif (v == 0) {\n\t\t\t\tmarks[i] = false;\n\t\t\t}\n\n\t\t\tfor (var j = i + 1; j < len; j++) {\n\t\t\t\t// 当数组中出现相等的值时\n\t\t\t\t// 那么都标记为false\n\t\t\t\tif (array[j] == v) {\n\t\t\t\t\tmarks[i] = marks[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn marks;\n\t}\n};\n\nvar Checker = function Checker() {\n\t_classCallCheck(this, Checker);\n};\n\nexports.checkerTool = checkerTool;\nexports.Checker = Checker;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(4);\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _matrix = __webpack_require__(0);\n\nvar _matrix2 = _interopRequireDefault(_matrix);\n\nvar _tool = __webpack_require__(1);\n\nvar _tool2 = _interopRequireDefault(_tool);\n\nvar _make = __webpack_require__(5);\n\nvar _make2 = _interopRequireDefault(_make);\n\nvar _checker = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// 工具测试\n/*\nlet items = matrix.makeMatrix();\nlet _arrs = items.map(item => item.map((v, i) => i));\nlet arrs = _arrs.map( arr => tool.shuffle(arr));\nconsole.log(arrs);\n\nlet cell = tool.convertPosition(5, 6);\nconsole.log(cell);\nlet box = matrix.boxMatrix(arrs, cell.rowIndex, cell.colIndex);\nconsole.log(box.boxValue);\nconsole.log(arrs[cell.rowIndex][cell.colIndex]);\nconsole.log(box.boxValueIndex);\n*/\n\n// make类测试\n/*\nconst maker = new Make();\nmaker.init();\nconsole.log(maker.matrix);\n*/\n\n// checker test\n\n// export default {name: 'test'}\nvar arr = [1, 2, 3, 4, 5, 8, 9, 7, 6];\nconsole.log(arr);\nconsole.log(_checker.checkerTool.checkArray(arr));\nvar arr1 = [1, 2, 0, 3, 4, 0, 0, 8, 9];\nconsole.log(arr1);\nconsole.log(_checker.checkerTool.checkArray(arr1));\nvar arr2 = [1, 1, 2, 0, 0, 3, 4, 5, 3];\nconsole.log(arr2);\nconsole.log(_checker.checkerTool.checkArray(arr2));\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // 数据生成工具\n\n// 计算工具\n\n// 检查工具\n\n\nvar _matrix = __webpack_require__(0);\n\nvar _matrix2 = _interopRequireDefault(_matrix);\n\nvar _tool = __webpack_require__(1);\n\nvar _tool2 = _interopRequireDefault(_tool);\n\nvar _checker = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// 生成数独，（随机计算出所有的格子应该填写的数字）\nvar Make = function () {\n\tfunction Make() {\n\t\t_classCallCheck(this, Make);\n\n\t\t// 九宫格二维数组\n\t\tthis.matrix = null;\n\t\t// 9 * 9 索引数组表\n\t\tthis.orders = null;\n\t}\n\n\t_createClass(Make, [{\n\t\tkey: \"init\",\n\t\tvalue: function init() {\n\t\t\twhile (!this._generator()) {\n\t\t\t\tconsole.log('do it');\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"_generator\",\n\t\tvalue: function _generator() {\n\t\t\t// 生成9 * 9 二维数组\n\t\t\t// 这里需要注意的是，每当数独生成失败就需要重置这个二维数组\n\t\t\t// 及实现清空操作，理解这一点也非常重要\n\t\t\tthis.matrix = _matrix2.default.makeMatrix();\n\t\t\t// 建立随机索引数组\n\t\t\t// 其实这里可以理解为是matri的索引表\n\t\t\t// 这个索引只是被打乱了，使得后面能在matrix中得到一个随机值\n\t\t\tthis.orders = _matrix2.default.makeMatrix().map(function (row) {\n\t\t\t\treturn row.map(function (v, i) {\n\t\t\t\t\treturn i;\n\t\t\t\t});\n\t\t\t}).map(function (row) {\n\t\t\t\treturn _tool2.default.shuffle(row);\n\t\t\t});\n\n\t\t\t// 填入 1 - 9 \n\t\t\tfor (var n = 1; n <= 9; n++) {\n\t\t\t\tif (!this._fillNumber(n)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}, {\n\t\tkey: \"_fillNumber\",\n\t\tvalue: function _fillNumber(n) {\n\t\t\t// 从第一行开始填写数字\n\t\t\treturn this._fillRow(n, 0);\n\t\t}\n\t}, {\n\t\tkey: \"_fillRow\",\n\t\tvalue: function _fillRow(n, row_index) {\n\t\t\t// 如果数字n在该行填写成功后，那么递归调用_fillRow()\n\t\t\t// 进行下一行中填写数字n\n\t\t\t// 最终需要将数字n，全部填入每一行，即row_index == 8\n\t\t\t// 当row_index > 8 就说明数字 n 全部填入成功\n\t\t\tif (row_index > 8) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// 调入二维数组\n\t\t\t// 这里其实就是给这个二维数值填值得过程\n\t\t\t// 需要注意的是，这里的原始数组，是通过matrix类生成的\n\t\t\t// 默认所有的值都为 0 ；\n\t\t\tvar row = this.matrix[row_index];\n\n\t\t\t// 获取该行的中各元素的随机索引值，\n\t\t\t// 后面将根据该索引值取值 \n\t\t\tvar orders = this.orders[row_index];\n\n\t\t\tfor (var i = 0; i < 9; i++) {\n\n\t\t\t\tvar col_index = orders[i];\n\t\t\t\t// 如果当前行中指定的位置已经填入数值\n\t\t\t\t// 那么跳过该位置\n\t\t\t\tif (row[col_index] != 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// 检查这个位置在‘列’ ‘行’和当前‘宫’中是否能填写\n\t\t\t\tif (!_checker.checkerTool.checkFillable(this.matrix, n, row_index, col_index)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trow[col_index] = n;\n\t\t\t\t// 注意这里需要将递归写进循环体内\n\t\t\t\t// 这样作的目的，是为了确保下一行能正确填写的情况下，\n\t\t\t\t// 那么才能确定本次填写是足够正确的\n\t\t\t\t// 这里一是为了验证本次的填写是否能保证下一行能正确填写\n\t\t\t\t// 同时也执行了下一行的填写，\n\t\t\t\t// 这是一个非常巧妙的递归运用\n\t\t\t\tif (!this._fillRow(n, row_index + 1)) {\n\t\t\t\t\trow[col_index] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// 该函数一直返回false\n\t\t\t// 除非row_index = 8\n\t\t\treturn false;\n\t\t}\n\t}]);\n\n\treturn Make;\n}();\n\nexports.default = Make;\n\n/***/ })\n/******/ ]);"],"file":"test.js"}